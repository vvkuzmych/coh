# UserManagement Engine Architecture

## Overview

The `user_management` engine is a Rails Engine that encapsulates all user-related functionality in the COH modular monolith. It provides a clean API boundary between the main application and user management concerns.

## Architecture Pattern: Engine with DTO & Public API

This implementation follows the **Bounded Context** pattern from Domain-Driven Design (DDD), using:
- **Internal Models**: `UserManagement::User` - ActiveRecord model with full database access
- **Data Transfer Objects (DTOs)**: `UserManagement::Dto::User` - Immutable value objects for cross-boundary communication
- **Public API**: `UserManagement::PublicApi::User` - Controlled interface for external access

### Why This Pattern?

1. **Encapsulation**: The main app cannot directly modify users; it must go through the API
2. **Decoupling**: Changes to internal user logic don't break the main app
3. **Security**: DTOs prevent unauthorized database access
4. **Testability**: Each layer can be tested independently
5. **Future-proofing**: Easy to extract into a microservice later

## Directory Structure

```
packages/user_management/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ user_management/
â”‚           â””â”€â”€ user.rb              # Internal ActiveRecord model
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ user_management/
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”œâ”€â”€ base.rb             # Base DTO class (reusable)
â”‚   â”‚   â”‚   â”œâ”€â”€ user.rb             # User Data Transfer Object
â”‚   â”‚   â”‚   â”œâ”€â”€ README.md           # DTO documentation
â”‚   â”‚   â”‚   â””â”€â”€ EXAMPLE.md          # DTO examples
â”‚   â”‚   â””â”€â”€ public_api/
â”‚   â”‚       â””â”€â”€ user.rb             # Public API interface
â”‚   â””â”€â”€ user_management.rb          # Engine loader
â””â”€â”€ user_management.gemspec
```

## Component Details

### 1. Internal Model: `UserManagement::User`

**Location**: `app/models/user_management/user.rb`

**Purpose**: ActiveRecord model with full database access. Should only be used internally within the engine.

**Key Features**:
- Full ActiveRecord functionality (validations, callbacks, scopes)
- Database relationships (belongs_to :account, has_many :documents)
- Business logic (role helpers, full_name)
- Uses `self.table_name = "users"` to map to the main database

**Example**:
```ruby
class UserManagement::User < ApplicationRecord
  self.table_name = "users"
  
  belongs_to :account, optional: true
  has_many :documents, class_name: "::Document", foreign_key: "user_id"
  
  enum :role, { guest: 0, member: 1, admin: 2, super_admin: 3 }, prefix: true
  
  validates :email, presence: true, uniqueness: true
  
  scope :administrators, -> { where(role: [:admin, :super_admin]) }
end
```

**âš ï¸ Important**: This model should **NOT** be accessed directly from the main app or other engines.

---

### 2. Data Transfer Object: `UserManagement::Dto::User`

**Location**: `lib/user_management/dto/user.rb`

**Purpose**: Immutable value object that safely exposes user data across boundaries.

**Key Features**:
- Read-only attributes (auto-generated by Base class)
- Initialized from a `UserManagement::User` instance or hash
- Includes only safe, public data
- No database access
- Lightweight and serializable
- Built-in `to_h`, `to_json`, and `inspect` methods

#### The DTO Base Class

All DTOs inherit from `UserManagement::Dto::Base`, which provides automatic attribute definition and initialization.

**Base Class Features**:
- ğŸ¯ **Automatic `attr_reader`** - No need to manually define accessors
- ğŸ¯ **Automatic initialization** - Maps attributes from source objects
- ğŸ¯ **Hash support** - Can initialize from hashes (great for testing)
- ğŸ¯ **Built-in methods** - `to_h`, `to_json`, `inspect`
- ğŸ¯ **Zero boilerplate** - Just list your attributes

**Example**:
```ruby
module UserManagement
  module Dto
    class User < Base
      # Define which attributes to expose (auto-creates attr_readers and initialize)
      attributes :id, :email, :first_name, :last_name, :account_id, :role, :created_at, :updated_at

      # Add custom methods
      def full_name
        "#{first_name} #{last_name}"
      end

      def administrator?
        role == "admin" || role == "super_admin"
      end
    end
  end
end
```

**Usage**:
```ruby
# From ActiveRecord model
user = UserManagement::User.find(1)
dto = UserManagement::Dto::User.new(user)

# From hash (perfect for testing)
dto = UserManagement::Dto::User.new({
  id: 1,
  email: "test@example.com",
  first_name: "John",
  last_name: "Doe"
})

# Built-in methods
dto.to_h      # => { id: 1, email: "test@example.com", ... }
dto.to_json   # => '{"id":1,"email":"test@example.com",...}'
dto.inspect   # => #<UserManagement::Dto::User id=1, email="test@example.com", ...>
```

**When to use DTOs**:
- âœ… When exposing data to the main app
- âœ… When returning data from APIs
- âœ… When passing data between engines
- âœ… When testing without database access
- âŒ Not needed for internal engine operations

**ğŸ“š See also**: `lib/user_management/dto/README.md` for complete DTO documentation and `EXAMPLE.md` for more examples.

---

### 3. Public API: `UserManagement::PublicApi::User`

**Location**: `lib/user_management/public_api/user.rb`

**Purpose**: The **only** interface the main app should use to access user data.

**Key Features**:
- Class methods only (stateless)
- Always returns DTOs, never ActiveRecord models
- Controlled access patterns
- Can enforce authorization, rate limiting, logging, etc.

**Available Methods**:

```ruby
# Get all users for an account
UserManagement::PublicApi::User.get_all_by_account_id(account_id)
# => Array of UserManagement::Dto::User

# Find a single user
UserManagement::PublicApi::User.find(id)
# => UserManagement::Dto::User or nil

# Find by email
UserManagement::PublicApi::User.find_by_email(email)
# => UserManagement::Dto::User or nil

# Get all users
UserManagement::PublicApi::User.all
# => Array of UserManagement::Dto::User

# Get administrators
UserManagement::PublicApi::User.administrators
# => Array of UserManagement::Dto::User

# Get regular users
UserManagement::PublicApi::User.regular_users
# => Array of UserManagement::Dto::User
```

**Example Implementation**:
```ruby
module UserManagement
  module PublicApi
    class User
      class << self
        def get_all_by_account_id(account_id)
          users = UserManagement::User.where(account_id: account_id)
          users.map { |user| UserManagement::Dto::User.new(user) }
        end
        
        def find(id)
          user = UserManagement::User.find_by(id: id)
          return nil unless user
          
          UserManagement::Dto::User.new(user)
        end
      end
    end
  end
end
```

---

## Usage in Main Application

### âœ… Correct Usage

#### In Account Model

```ruby
class Account < ApplicationRecord
  def users
    # Use PublicApi to get users as DTOs
    UserManagement::PublicApi::User.get_all_by_account_id(id)
  end
  
  def documents
    # Query User IDs internally for efficient document loading
    user_ids = UserManagement::User.where(account_id: id).pluck(:id)
    Document.where(user_id: user_ids)
  end
end
```

#### In Document Model

```ruby
class Document < ApplicationRecord
  # Reference the internal model for ActiveRecord associations
  belongs_to :user, class_name: "UserManagement::User", foreign_key: "user_id"
  
  # Delegate to access user properties
  delegate :account, to: :user
end
```

### âŒ Incorrect Usage

```ruby
# DON'T: Direct instantiation of internal model
user = UserManagement::User.new(email: "test@example.com")

# DON'T: Direct queries without going through PublicApi
users = UserManagement::User.where(role: :admin)

# DON'T: Direct updates to user attributes
user = UserManagement::User.find(1)
user.update(email: "new@example.com")
```

**Why?** These bypass the API boundary and couple the main app to internal implementation details.

---

## Database Relationships

### Users Table

The `users` table lives in the main database but is managed by the `UserManagement::User` model:

```ruby
# Migration
create_table "users" do |t|
  t.string "email", null: false
  t.string "first_name", null: false
  t.string "last_name", null: false
  t.bigint "account_id"
  t.integer "role", default: 0, null: false
  t.timestamps
  
  t.index ["account_id"]
  t.index ["email"], unique: true
  t.index ["role"]
end

add_foreign_key "users", "accounts"
```

### Cross-Boundary Relationships

**Problem**: How does the main app's `Document` model relate to `UserManagement::User`?

**Solution**: Use `class_name` option:

```ruby
class Document < ApplicationRecord
  belongs_to :user, class_name: "UserManagement::User", foreign_key: "user_id"
end
```

This allows ActiveRecord associations while maintaining encapsulation.

---

## Benefits of This Architecture

### 1. **Separation of Concerns**
- User management logic is isolated
- Main app doesn't know about user internals

### 2. **Controlled Access**
- All user access goes through PublicApi
- Easy to add authorization, logging, caching

### 3. **Flexibility**
- Can replace DTO implementation (e.g., add caching)
- Can change internal User model without breaking the app

### 4. **Testability**
- Test each layer independently
- Mock PublicApi for main app tests

### 5. **Future-proofing**
- Easy to extract into a microservice
- Already has a clean API contract

### 6. **Security**
- DTOs prevent accidental data leaks
- No way to bypass validations via direct access

---

## Trade-offs

### âœ… Pros
- Clean boundaries
- Easy to understand ownership
- Safe for large teams
- Future-proof

### âš ï¸ Cons
- More files to maintain
- Slight performance overhead (DTO creation)
- Requires discipline (don't bypass the API)

---

## Testing Strategy

### Testing Internal Model

```ruby
# packages/user_management/spec/models/user_management/user_spec.rb
RSpec.describe UserManagement::User do
  it "validates email presence" do
    user = UserManagement::User.new(first_name: "John", last_name: "Doe")
    expect(user).not_to be_valid
  end
end
```

### Testing DTO

```ruby
# packages/user_management/spec/lib/user_management/dto/user_spec.rb
RSpec.describe UserManagement::Dto::User do
  it "exposes user attributes" do
    user = UserManagement::User.create!(email: "test@example.com", ...)
    dto = UserManagement::Dto::User.new(user)
    
    expect(dto.email).to eq("test@example.com")
    expect(dto.full_name).to eq("John Doe")
  end
end
```

### Testing Public API

```ruby
# packages/user_management/spec/lib/user_management/public_api/user_spec.rb
RSpec.describe UserManagement::PublicApi::User do
  it "returns DTOs for account users" do
    account = Account.create!(name: "Test")
    user = UserManagement::User.create!(account: account, ...)
    
    dtos = UserManagement::PublicApi::User.get_all_by_account_id(account.id)
    
    expect(dtos).to all(be_a(UserManagement::Dto::User))
    expect(dtos.first.email).to eq(user.email)
  end
end
```

### Testing Main App Integration

```ruby
# spec/models/account_spec.rb
RSpec.describe Account do
  it "fetches users via PublicApi" do
    account = Account.create!(name: "Test")
    UserManagement::User.create!(account: account, email: "test@example.com", ...)
    
    users = account.users
    
    expect(users).to all(be_a(UserManagement::Dto::User))
  end
end
```

---

## Adding New PublicApi Methods

When you need new user functionality:

1. **Add internal logic to User model** (if needed)
2. **Add method to PublicApi::User**
3. **Return DTO(s)**
4. **Test the API method**

**Example**: Adding a method to get active users

```ruby
# 1. Add scope to UserManagement::User
class UserManagement::User < ApplicationRecord
  scope :active, -> { where(active: true) }
end

# 2. Add method to PublicApi
module UserManagement
  module PublicApi
    class User
      class << self
        def active_users
          users = UserManagement::User.active
          users.map { |user| UserManagement::Dto::User.new(user) }
        end
      end
    end
  end
end

# 3. Use in main app
active_users = UserManagement::PublicApi::User.active_users
```

---

## Summary

This architecture provides:
- âœ… Clean separation between internal and external concerns
- âœ… Safe, controlled access to user data
- âœ… Future-proof for microservices
- âœ… Testable and maintainable

**Remember**: Always access users through `UserManagement::PublicApi::User`, never directly through `UserManagement::User` from the main app!
